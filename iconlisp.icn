global kLPar
global kRPar
global kQuote
global kNil
global sym_table
global sym_quote

procedure safeCar(obj)
    if obj["tag"] == "cons" then
        return obj["car"]
    else
        return kNil
end

procedure safeCdr(obj)
    if obj["tag"] == "cons" then
        return obj["cdr"]
    else
        return kNil
end

procedure makeNum(num)
    local obj
    obj := table()
    obj["tag"] := "num"
    obj["data"] := num
    return obj
end

procedure makeSym(str)
    local obj
    if /sym_table[str] then {
        obj := table()
        obj["tag"] := "sym"
        obj["data"] := str
        sym_table[str] := obj
    }
    return sym_table[str]
end

procedure makeError(str)
    local obj
    obj := table()
    obj["tag"] := "error"
    obj["data"] := str
    return obj
end

procedure makeCons(a, d)
    local obj
    obj := table()
    obj["tag"] := "cons"
    obj["car"] := a
    obj["cdr"] := d
    return obj
end

procedure nreverse(lst)
    local ret, tmp
    ret := kNil
    while lst["tag"] == "cons" do {
        tmp := lst["cdr"]
        lst["cdr"] := ret
        ret := lst
        lst := tmp
    }
    return ret
end

procedure isSpace(c)
    if c == "\t" | c == "\l" | c == "\n" | c == " " then
        return c
    else
        fail
end

procedure isDelimiter(c)
    if c == kLPar | c == kRPar | c == kQuote | isSpace(c) then
        return c
    else
        fail
end

procedure skipSpaces(str)
    local i
    i := 1
    while (str[i]) do {
        if not isSpace(str[i]) then return str[i:0]
        i +:= 1
    }
    return ""
end

procedure makeNumOrSym(str)
    if integer(str) then
        return makeNum(integer(str))
    else
        return makeSym(str)
end

procedure readAtom(str)
    local nxt, i
    nxt := ""
    i := 1
    while (str[i]) do {
        if isDelimiter(str[i]) then {
            nxt := str[i:0]
            str := str[1:i]
            break
        }
        i +:= 1
    }
    return [makeNumOrSym(str), nxt]
end

procedure read1(str)
    local tmp
    str := skipSpaces(str)
    if str == "" then
        return [makeError("empty input"), ""]
    else if str[1] == kRPar then
        return [makeError("invalid syntax: " || str), ""]
    else if str[1] == kLPar then
        return readList(str[2:0])
    else if str[1] == kQuote then {
        tmp := read1(str[2:0])
        return [makeCons(sym_quote, makeCons(tmp[1], kNil)), tmp[2]]
    }
    else
        return readAtom(str)
end

procedure readList(str)
    local ret, tmp
    ret := kNil
    while 1 do {
        str := skipSpaces(str)
        if str == "" then
            return [makeError("unfinished parenthesis"), ""]
        else if str[1] == kRPar then
            break
        tmp := read1(str)
        if tmp[1]["tag"] == "error" then
            return tmp
        ret := makeCons(tmp[1], ret)
        str := tmp[2]
    }
    return [nreverse(ret), str[2:0]]
end

procedure printObj(obj)
    local tag
    tag := obj["tag"]
    if tag == "nil" then
        return "nil"
    else if tag == "num" | tag == "sym" then
        return obj["data"]
    else if tag == "error" then
        return "<error: " || obj["data"] || ">"
    else if tag == "cons" then
        return printList(obj)
    else if tag == "subr" then
        return "<subr>"
    else if tag == "expr" then
        return "<expr>"
    else
        return "<unknown>"
end

procedure printList(obj)
    local ret, first
    ret := ""
    first := 1
    while obj["tag"] == "cons" do {
        if first = 1 then
            first := 0
        else
            ret ||:= " "
        ret ||:= printObj(obj["car"])
        obj := obj["cdr"]
    }
    if obj === kNil then
        return "(" || ret || ")"
    else
        return "(" || ret || " . " || printObj(obj) || ")"
end

procedure init()
    kLPar := "("
    kRPar := ")"
    kQuote := "'"

    kNil := table()
    kNil["tag"] := "nil";

    sym_table := table(false)
    sym_table["nil"] := kNil

    sym_quote := makeSym("quote")
end

procedure main(args)
    local exp
    init()
    while (exp := read1(read())) do {
        write(printObj(exp[1]))
    }
end
